{"pageProps":{"frontmatter":{"title":"Power Up Diffusion LLMs: Day‑0 Support for LLaDA 2.0","author":"Ant Group DeepXPU Team, SGLang Team","date":"December 19, 2025","previewImg":"/images/blog/dllm/preview.png"},"content":"\n## TL;DR\n\nWe are excited to introduce the design and implementation of the Diffusion Large Language Model (dLLM) framework within SGLang. By leveraging the existing Chunked-Prefill mechanism, our system achieves:\n\n- Seamless integration: Built into the SGLang ecosystem without core architectural changes.\n- Inherited performance: The framework benefits from the existing inference optimization.\n- Maximum flexibility: Full flexibility for users to define and customize diffusion decoding algorithms.\n\n## Background\n\n### Motivation\nEarlier this year, [LLaDA](https://arxiv.org/pdf/2502.09992) made its debut as the first Diffusion Large Language Model, immediately capturing significant attention from both the academic and industrial communities. This achievement, a collaboration between Renmin University of China and Ant Group, demonstrated that the unique execution paradigm of dLLMs exhibits superior data comprehension capabilities. Moreover, dLLMs enable faster inference speeds compared to Auto-Regressive models, especially in low-latency scenarios such as small batch sizes.\n\nAt the same time, as the parameter scale of dLLMs continues to grow, we have also observed scaling-law effects similar to those seen in AR LLMs. In pursuit of better dLLMs, we trained the 100B [LLaDA2.0-flash](https://github.com/inclusionAI/LLaDA2.0/blob/main/tech_report.pdf) model.\n\nHowever, in the process of training the [LLaDA2.0-flash](https://github.com/inclusionAI/LLaDA2.0/blob/main/tech_report.pdf), we encountered a series of serious AI infrastructure engineering challenges. The most important challenges are the efficency and stability of model evaluation and RL post training.\n\n### Challenges\n\nThe current inference engines available for dLLMs are insufficient to support the evaluation and RL post-training requirements of larger-scale dLLMs. For instance, tools like [Fast-dLLM](https://github.com/NVlabs/Fast-dLLM) are excellent research tools, better suited for algorithm researchers to tune and validate various Diffusion decoding algorithms. However, they fall short in providing production-ready serving capabilities, such as batching, scheduling, RL ecosystem integration, and parallelism.\n\nIn contrast, SGLang is one of the most popular LLM inference engines today and has multiple advantages:\n\n1. Production-Ready: It has been deployed in inference services across thousands of companies, offering mature and reliable engineering capabilities.\n2. Technological Lead: SGLang itself incorporates a vast array of excellent and advanced inference optimization techniques, with a continuous flow of new optimizations emerging from the community.\n3. Complete Ecosystem: It integrates extremely well with the RL post-training ecosystem, particularly in areas like distributed weight GPU P2P updates.\n\nHowever, the core issue is that SGLang currently only supports the Auto-Regressive calculation paradigm, and has not yet adapted to the diffusion calculation method for LLMs.\n\nTherefore, the challenge we face is: How can we introduce support for the dLLMs within the existing SGLang framework without compromising its current architecture? The goal is two-fold: allow dLLMs to benefit from all the optimization advantages SGLang offers, while avoiding major, compromising modifications to the SGLang framework just to accommodate diffusion computation.\n\n## Design\n\n### Key Insights\n\nBased on our observations of the current developments in dLLM, we have identified several key insights:\n\n1. Due to the enormous computational cost of Bidirectional Attention Diffusion and its inefficient utilization of the KV Cache, mainstream dLLMs are increasingly moving toward the Block Diffusion architecture.\n2. The computation pattern of Block Diffusion bears a high degree of similarity to SGLang's existing Chunked-Prefill process.\n3. Unlike auto-regressive language models, diffusion language models utilize various decoding strategies, which require a dedicated interface for flexible decoding algorithm customization.\n\n### Architecture\n\nOur approach is to leverage SGLang’s existing Chunked-Prefill pipeline to implement computational support for Block Diffusion LLM. This method allows us to seamlessly integrate dLLM into the SGLang ecosystem without changing the core SGLang framework, enabling dLLM to directly benefit from all the inference optimization techniques SGLang has accumulated.\n\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/main-flow.png\" alt=\"main execution flow\">\n  <br>\n</p>\n\n\nAs illustrated in the diagram, our modifications to the SGLang framework are very restrained, barely touching its core. SGLang's original `generate request` execution flow remains unchanged. Our implementation primarily focuses on leveraging and modifying its existing Chunked Prefill mechanism, with the specific work concentrated on two critical components: the `prefill adder` and `chunked reqs`.\n\nIn SGLang, the initial purpose of Chunked Prefill was to maximize GPU utilization. Consequently, the size of a single chunk is typically set quite large—ranging from 2K to 16K tokens in sequence length, depending on the GPU model. When the sequence is long enough, it naturally processes only one request, which is how the current `prefill adder` and `chunked req` are implemented.\n\nHowever, the decoding process for dLLM differs: it segments the sequence length at the block level. Taking LLaDA2.0 as an example, its block Size is 32 tokens. If we were to follow SGLang's previous logic of processing only one large request at a time, GPU performance would clearly be wasted. Therefore, batching is a crucial problem that must be solved. To achieve efficient batching, we modified both `chunked reqs` and the `prefill adder` to enable them to process multiple Diffusion Blocks within a single computation cycle.\n\nFurthermore, at the actual decoding execution level, we inserted an abstraction layer for the diffusion algorithm between the TP Worker and the Model Runner.\n\nSpecifically:\n- If the Worker identifies that it is handling a Diffusion model, the execution flow enters this dedicated branch.\n- The TP Worker then calls the Diffusion algorithm's `run` function.\n- Internally, this algorithm utilizes a forward iteration loop to continuously drive the Model Runner to perform inference computations until the entire Block (e.g., all 32 tokens) is decoded.\n\n### Attention Mask\n\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/casual-mask.png\" alt=\"Logo preview\">\n  <br>\n</p>\n\nThe most significant difference between Block Diffusion and Chunk Prefill during a single model forward pass lies in the handling of the attention mask.\n\n- Block Diffusion utilizes a block-wise causal mask.\n- Chunk Prefill for AR model uses the traditional token-wise causal mask.\n\nWe can view Block Diffusion as a functional extension to the existing Chunk Prefill mechanism within SGLang. Regarding the specific attention calculation, a single forward pass involves two computational parts, whose final outputs are concatenated:\n\n1. Context Query: This uses the current `Q_curr` (the query vectors of the current block) to perform bidirectional attention against the existing KV Cache. This computation is completely identical for both Block Diffusion and Chunk Prefill. The objective here is to ensure the current block attends to all historical information.\n2. Intra-Block Query: This uses the current `Q_curr` against its own KV (i.e., the keys and values within the current block) to perform the forward calculation.\n    - Block Diffusion employs bidirectional attention in this step.\n    - Chunk Prefill must use a causal Mask in this step.\n\nSimply put, if we visualize the attention mask as a geometric shape for the `Q_curr` portion:\n  - The calculation for Chunk Prefill (causal mask) corresponds to a trapezoidal (or triangular) mask.\n  - The calculation for Block Diffusion (bidirectional attention) corresponds to a rectangular mask.\n\n## Streaming output animation\n\nHere is an animation comparing the streaming output of LLaDA2.0-flash-CAP (100B / BF16) and gpt-oss-120B (117B / MXFP4). LLaDA2.0-flash-CAP is served using SGLang dLLM with TP8 on 8 × H20, while gpt-oss-120B is served using SGLang's standard AR process on the same hardware.\n\nBoth models are asked to implement the quicksort algorithm in 10 programming languages — a task particularly well-suited for diffusion LLMs. As shown, LLaDA2.0-flash-CAP achieves significantly higher throughput at 935 tokens/s, compared to gpt-oss-120B (263 tokens/s) in this scenario.\n\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/llada2-vs-gpt-oss.gif\" alt=\"LLaDA2.0-flash-CAP vs gpt-oss-120B animation\">\n  <br>\n</p>\n\nSGLang dLLM supports streaming output just like SGLang auto-regressive models: but it outputs one block (e.g., 32 tokens) at a time instead of one token.\n\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/dllm-animation.gif\" alt=\"Logo preview\">\n  <br>\n</p>\n\n## How to Use\n\n### Example Launch Command\n\n```shell\npython3 -m sglang.launch_server \\\n  --model-path inclusionAI/LLaDA2.0-mini \\ # example HF/local path\n  --dllm-algorithm LowConfidence \\\n  --dllm-algorithm-config ./config.yaml \\ # Optional. Uses the algorithm's default if not set.\n  --host 0.0.0.0 \\\n  --port 30000\n```\n> NOTE: Use `--dllm-algorithm-config` for advanced configuration of the selected `--dllm-algorithm`. This feature decouples configuration from code, enabling flexible customization and argument passing for user-defined algorithms via a unified entry point.\n\n### Example Client Code Snippet\n\nJust like other supported models, dLLMs can be used via the REST API or offline engine API.\n\nCurl example for making a generation request to the running server:\n\n```bash\ncurl -X POST \"http://127.0.0.1:30000/generate\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n        \"text\": [\n            \"<role>SYSTEM</role>detailed thinking off<|role_end|><role>HUMAN</role>Write the number from 1 to 128<|role_end|><role>ASSISTANT</role>\",\n            \"<role>SYSTEM</role>detailed thinking off<|role_end|><role>HUMAN</role>Write a brief introduction of the great wall<|role_end|><role>ASSISTANT</role>\"\n        ],\n        \"stream\": true,\n        \"sampling_params\": {\n            \"temperature\": 0,\n            \"max_new_tokens\": 1024\n        }\n    }'\n```\n\nThe following contains a code snippet illustrating how to use the offline engine generate content based on given inputs:\n\n```python\nimport sglang as sgl\n\ndef main():\n    llm = sgl.Engine(model_path=\"inclusionAI/LLaDA2.0-mini\",\n                     dllm_algorithm=\"LowConfidence\",\n                     max_running_requests=1,\n                     trust_remote_code=True)\n\n    prompts = [\n        \"<role>SYSTEM</role>detailed thinking off<|role_end|><role>HUMAN</role>Write a brief introduction of the great wall<|role_end|><role>ASSISTANT</role>\"\n    ]\n\n    sampling_params = {\n        \"temperature\": 0,\n        \"max_new_tokens\": 1024,\n    }\n\n    outputs = llm.generate(prompts, sampling_params)\n    print(outputs)\n\nif __name__ == '__main__':\n    main()\n```\n\n## Performance\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/llada2_flash_main_bench.png\" alt=\"LLaDA2.0-flash main results\">\n  <br>\n</p>\n\nWe assessed the task efficacy of LLaDA2.0-flash by benchmarking it against advanced Auto-Regressive (AR) models of a comparable scale on a wide range of standard evaluation tasks.\n\nThe overall results indicate that the LLaDA2.0 architecture is not only highly competitive, but also shows a promising trend of closing the capability gap with AR models.\n\n<p align=\"center\">\n  <img src=\"/images/blog/dllm/llada2_despine_comparison.png\" alt=\"LLaDA2.0-flash performance\">\n  <br>\n</p>\n\nThe chart presents two complementary measurements for LLaDA2.0‑flash:\n- Average score and tokens‑per‑forward (TPF) obtained with and without Confidence‑Aware Parallel (CAP) training across 12 benchmark tasks.\n- Inference speed (tokens per second) of LLaDA2.0‑flash, benchmarked against AR models of comparable size on HumanEval, MBPP, GSM8K, and CRUXEval suites.\n\nAll numbers are collected under a consistent serving environment (SGLang with TP8 on H20), ensuring a fair comparison between the diffusion LLM and the Auto-Regressive baselines.\n\nWith a 0.95 threshold decoder, LLaDA2.0-flash-CAP achieved 500 TPS, significantly outperforming standard LLaDA2.0-flash (383 TPS) and delivering up to a 1.9× speedup over AR baselines (258 TPS and 237 TPS) with small batch sizes.\n\n## Roadmap\n\n### Implemented key features\n\nThe current implementation fully supports the following critical serving features:\n\n- Block Diffusion LLM framework main logic\n- Full KV cache support for sequence management\n- Model integration for LLaDA-2.0-mini/flash\n- Support for custom decoding algorithm\n- Full streaming I/O capability\n- Batching support (reviewing)\n- Tensor parallelism support\n- Cuda graph optimization\n\n### Mid & Long-term Roadmaps\n\n[Roadmap for 2025-Q4 and 2026-Q1](https://github.com/sgl-project/sglang/issues/14199)<br>\n[RFC: Block Diffusion Large Language Model (dLLM) Framework In SGLang](https://github.com/sgl-project/sglang/issues/12766)<br>\n- Support more system optimizations that autoregressive language models already have\n- Integrate additional common diffusion decoding strategies/algorithms (e.g, [Fast-dLLM v2](https://arxiv.org/pdf/2509.26328))\n- Add compatibility for non-block dLLMs (e.g., LLaDA & RND1)\n\n## Reference\n[LLaDA1 technique report](https://arxiv.org/pdf/2502.09992)<br>\n[LLaDA2 technique report](https://github.com/inclusionAI/LLaDA2.0/blob/main/tech_report.pdf)<br>\n[Fast-dLLM v2 technique report](https://arxiv.org/pdf/2509.26328)\n\n## Acknowledgements\n\n- Ant Group DeepXPU Team: [Zehuan Li](https://github.com/Clawseven), [Tiwei Bie](https://github.com/btw616), Zhonghui Jiang, Jinghua Yao, Yusong Gao, [Mingliang Gong](https://github.com/brightcoder01), Jianfeng Tan\n- Ant Group inclusionAI Team: Kun Chen, [Zenan Huang](https://lccurious.github.io/), Lin Liu, Fuyuan Chen, Lun Du, Da Zheng \n- SGLang dLLM Team: [Jinwei Yao](https://kivi-yao.github.io/), [Mick Qian](https://github.com/mickqian), [Liangsheng Yin](https://www.lsyin.me/), [BBuf](https://github.com/BBuf), Banghua Zhu, [Chenyang Zhao](https://zhaochenyang20.github.io/Chayenne/)\n- NVIDIA Fast-dLLM Team: [Chengyue Wu](https://hills-code.github.io/), [Hao Zhang](https://research.nvidia.com/person/hao-zhang), [Enze Xie](https://xieenze.github.io/), [Song Han](https://hanlab.mit.edu/songhan)\n","slug":"2025-12-17-diffusion-llm"},"__N_SSG":true}